function [featureTable,outputTable] = diagnosticFeatures(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A table or a cell array of tables/matrices containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  outputTable: A table containing the computation results.
%
% This function computes spectra:
%  TimeTable_ps/SpectrumData
%  TimeTable1_ps/SpectrumData
%  TimeTable2_ps/SpectrumData
%  TimeTable3_ps/SpectrumData
%  TimeTable4_ps/SpectrumData
%  TimeTable5_ps/SpectrumData
%  TimeTable6_ps/SpectrumData
%  TimeTable7_ps/SpectrumData
%  TimeTable8_ps/SpectrumData
%  TimeTable9_ps/SpectrumData
%  TimeTable10_ps/SpectrumData
%  TimeTable11_ps/SpectrumData
%
% This function computes features:
%  TimeTable_ps_spec/PeakAmp1
%  TimeTable_ps_spec/PeakFreq1
%  TimeTable_ps_spec/BandPower
%  TimeTable1_ps_spec/PeakAmp1
%  TimeTable1_ps_spec/PeakFreq1
%  TimeTable1_ps_spec/BandPower
%  TimeTable2_ps_spec/PeakAmp1
%  TimeTable2_ps_spec/PeakFreq1
%  TimeTable2_ps_spec/BandPower
%  TimeTable3_ps_spec/PeakAmp1
%  TimeTable3_ps_spec/PeakFreq1
%  TimeTable3_ps_spec/BandPower
%  TimeTable4_ps_spec/PeakAmp1
%  TimeTable4_ps_spec/PeakFreq1
%  TimeTable4_ps_spec/BandPower
%  TimeTable5_ps_spec/PeakAmp1
%  TimeTable5_ps_spec/PeakFreq1
%  TimeTable5_ps_spec/BandPower
%  TimeTable6_ps_spec/PeakAmp1
%  TimeTable6_ps_spec/PeakFreq1
%  TimeTable6_ps_spec/BandPower
%  TimeTable7_ps_spec/PeakAmp1
%  TimeTable7_ps_spec/PeakFreq1
%  TimeTable7_ps_spec/BandPower
%  TimeTable8_ps_spec/PeakAmp1
%  TimeTable8_ps_spec/PeakFreq1
%  TimeTable8_ps_spec/BandPower
%  TimeTable9_ps_spec/PeakAmp1
%  TimeTable9_ps_spec/PeakFreq1
%  TimeTable9_ps_spec/BandPower
%  TimeTable10_ps_spec/PeakAmp1
%  TimeTable10_ps_spec/PeakFreq1
%  TimeTable10_ps_spec/BandPower
%  TimeTable11_ps_spec/PeakAmp1
%  TimeTable11_ps_spec/PeakFreq1
%  TimeTable11_ps_spec/BandPower
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 24-May-2023 07:39:01

% Create output ensemble.
outputEnsemble = workspaceEnsemble(inputData,'DataVariables',["TimeTable";"TimeTable1";"TimeTable2";"TimeTable3";"TimeTable4";"TimeTable5";"TimeTable6";"TimeTable7";"TimeTable8";"TimeTable9";"TimeTable10";"TimeTable11"]);

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"TimeTable_ps";"TimeTable1_ps";"TimeTable2_ps";"TimeTable3_ps";"TimeTable4_ps";"TimeTable5_ps";"TimeTable6_ps";"TimeTable7_ps";"TimeTable8_ps";"TimeTable9_ps";"TimeTable10_ps";"TimeTable11_ps";"TimeTable_ps_spec";"TimeTable1_ps_spec";"TimeTable2_ps_spec";"TimeTable3_ps_spec";"TimeTable4_ps_spec";"TimeTable5_ps_spec";"TimeTable6_ps_spec";"TimeTable7_ps_spec";"TimeTable8_ps_spec";"TimeTable9_ps_spec";"TimeTable10_ps_spec";"TimeTable11_ps_spec"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = ["TimeTable","TimeTable1","TimeTable2","TimeTable3","TimeTable4","TimeTable5","TimeTable6","TimeTable7","TimeTable8","TimeTable9","TimeTable10","TimeTable11"];

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Get all input variables.
    TimeTable = readMemberData(member,"TimeTable",["Time","21:07 Angle over Rolls (degrees)"]);
    TimeTable1 = readMemberData(member,"TimeTable1",["Time","21:10 Position over Rolls (mm)"]);
    TimeTable2 = readMemberData(member,"TimeTable2",["Time","21:12 Actual moment over Rolls (Nm)"]);
    TimeTable3 = readMemberData(member,"TimeTable3",["Time","21:17 Angle under roll (degrees)"]);
    TimeTable4 = readMemberData(member,"TimeTable4",["Time","21:20 Actual moment under Rolls (Nm)"]);
    TimeTable5 = readMemberData(member,"TimeTable5",["Time","21:28 Vibration measurements (mm per s)"]);
    TimeTable6 = readMemberData(member,"TimeTable6",["Time","21:31 Width position (mm)"]);
    TimeTable7 = readMemberData(member,"TimeTable7",["Time","21:32 Height position (mm)"]);
    TimeTable8 = readMemberData(member,"TimeTable8",["Time","21:33 Error position for height (mm)"]);
    TimeTable9 = readMemberData(member,"TimeTable9",["Time","21:34 Error position for the width (mm)"]);
    TimeTable10 = readMemberData(member,"TimeTable10",["Time","21:35 Set point force (KN)"]);
    TimeTable11 = readMemberData(member,"TimeTable11",["Time","21:36 Actual force (KN)"]);

    % Initialize a table to store results.
    memberResult = table;

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable.("21:07 Angle over Rolls (degrees)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable_ps = ps;
    catch
        TimeTable_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable_ps},'VariableNames',"TimeTable_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable1.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable1.("21:10 Position over Rolls (mm)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable1_ps = ps;
    catch
        TimeTable1_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable1_ps},'VariableNames',"TimeTable1_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable2.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable2.("21:12 Actual moment over Rolls (Nm)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable2_ps = ps;
    catch
        TimeTable2_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable2_ps},'VariableNames',"TimeTable2_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable3.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable3.("21:17 Angle under roll (degrees)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable3_ps = ps;
    catch
        TimeTable3_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable3_ps},'VariableNames',"TimeTable3_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable4.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable4.("21:20 Actual moment under Rolls (Nm)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable4_ps = ps;
    catch
        TimeTable4_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable4_ps},'VariableNames',"TimeTable4_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable5.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable5.("21:28 Vibration measurements (mm per s)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable5_ps = ps;
    catch
        TimeTable5_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable5_ps},'VariableNames',"TimeTable5_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable6.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable6.("21:31 Width position (mm)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable6_ps = ps;
    catch
        TimeTable6_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable6_ps},'VariableNames',"TimeTable6_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable7.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable7.("31:32 Height position (?)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable7_ps = ps;
    catch
        TimeTable7_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable7_ps},'VariableNames',"TimeTable7_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable8.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable8.("21:33 Error position for height (?)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable8_ps = ps;
    catch
        TimeTable8_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable8_ps},'VariableNames',"TimeTable8_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable9.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable9.("21:34 Error position for the width (?)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable9_ps = ps;
    catch
        TimeTable9_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable9_ps},'VariableNames',"TimeTable9_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable10.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable10.("21:35 Set point force (KN)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable10_ps = ps;
    catch
        TimeTable10_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable10_ps},'VariableNames',"TimeTable10_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(TimeTable11.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = TimeTable11.("21:36 Actual force (KN)");
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,4,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        TimeTable11_ps = ps;
    catch
        TimeTable11_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable11_ps},'VariableNames',"TimeTable11_ps")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable_ps.SpectrumData;
        w = TimeTable_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable_ps_spec},'VariableNames',"TimeTable_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable1_ps.SpectrumData;
        w = TimeTable1_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.00159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable1_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable1_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable1_ps_spec},'VariableNames',"TimeTable1_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable2_ps.SpectrumData;
        w = TimeTable2_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*1.59154943091895e-05) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable2_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable2_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable2_ps_spec},'VariableNames',"TimeTable2_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable3_ps.SpectrumData;
        w = TimeTable3_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.000159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable3_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable3_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable3_ps_spec},'VariableNames',"TimeTable3_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable4_ps.SpectrumData;
        w = TimeTable4_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*1.59154943091895e-05) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable4_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable4_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable4_ps_spec},'VariableNames',"TimeTable4_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable5_ps.SpectrumData;
        w = TimeTable5_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable5_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable5_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable5_ps_spec},'VariableNames',"TimeTable5_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable6_ps.SpectrumData;
        w = TimeTable6_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable6_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable6_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable6_ps_spec},'VariableNames',"TimeTable6_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable7_ps.SpectrumData;
        w = TimeTable7_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable7_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable7_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable7_ps_spec},'VariableNames',"TimeTable7_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable8_ps.SpectrumData;
        w = TimeTable8_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.000159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable8_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable8_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable8_ps_spec},'VariableNames',"TimeTable8_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable9_ps.SpectrumData;
        w = TimeTable9_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*1.59154943091895e-05) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable9_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable9_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable9_ps_spec},'VariableNames',"TimeTable9_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable10_ps.SpectrumData;
        w = TimeTable10_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable10_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable10_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable10_ps_spec},'VariableNames',"TimeTable10_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = TimeTable11_ps.SpectrumData;
        w = TimeTable11_ps.Frequency;
        w = factor*w;
        mask_1 = (w>=factor*0.159154943091895) & (w<=factor*25);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
        peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakFreq1 = peakFreq(1);
        BandPower = trapz(w/factor,ps);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakFreq1,BandPower];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable11_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,3);
        featureNames = ["PeakAmp1","PeakFreq1","BandPower"];
        TimeTable11_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({TimeTable11_ps_spec},'VariableNames',"TimeTable11_ps_spec")]; %#ok<AGROW>

    %% Write all the results for the current member to the ensemble.
    writeToLastMemberRead(outputEnsemble,memberResult)
end

% Gather all features into a table.
selectedFeatureNames = ["TimeTable_ps_spec/PeakAmp1","TimeTable_ps_spec/PeakFreq1","TimeTable_ps_spec/BandPower","TimeTable1_ps_spec/PeakAmp1","TimeTable1_ps_spec/PeakFreq1","TimeTable1_ps_spec/BandPower","TimeTable2_ps_spec/PeakAmp1","TimeTable2_ps_spec/PeakFreq1","TimeTable2_ps_spec/BandPower","TimeTable3_ps_spec/PeakAmp1","TimeTable3_ps_spec/PeakFreq1","TimeTable3_ps_spec/BandPower","TimeTable4_ps_spec/PeakAmp1","TimeTable4_ps_spec/PeakFreq1","TimeTable4_ps_spec/BandPower","TimeTable5_ps_spec/PeakAmp1","TimeTable5_ps_spec/PeakFreq1","TimeTable5_ps_spec/BandPower","TimeTable6_ps_spec/PeakAmp1","TimeTable6_ps_spec/PeakFreq1","TimeTable6_ps_spec/BandPower","TimeTable7_ps_spec/PeakAmp1","TimeTable7_ps_spec/PeakFreq1","TimeTable7_ps_spec/BandPower","TimeTable8_ps_spec/PeakAmp1","TimeTable8_ps_spec/PeakFreq1","TimeTable8_ps_spec/BandPower","TimeTable9_ps_spec/PeakAmp1","TimeTable9_ps_spec/PeakFreq1","TimeTable9_ps_spec/BandPower","TimeTable10_ps_spec/PeakAmp1","TimeTable10_ps_spec/PeakFreq1","TimeTable10_ps_spec/BandPower","TimeTable11_ps_spec/PeakAmp1","TimeTable11_ps_spec/PeakFreq1","TimeTable11_ps_spec/BandPower"];
featureTable = readFeatureTable(outputEnsemble,'Features',selectedFeatureNames);

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');

% Gather results into a table.
outputTable = readall(outputEnsemble);
end
